import groovy.json.*
def jsonContent='''
{
   "testCases":[
      {
         "id":"",
         "type":"CICS",
         "name":"DEFECT ITEM: ZPROJ-112",
         "description":"RECORDINGS:\nSSC1 TRANSACTION - RECORDED PRODUCTION ISSUE FOR INQUIRE CUSTOMER FUNCTION",
         "dataset":"DMJTA1.DEFECT.DOB",
         "dateRecorded":"2021222092757000",
         "transactions":[
            {
               "name":"SSC1",
               "maps":[
                  "SSMAPC1"
               ],
               "mapSets":[
                  "SSMAP  "
               ],
               "db2Subsystems":[
                  "DSN0"
               ],
               "programs":[
                  "LGTESTC1",
                  "LGICUS01",
                  "LGICDB01"
               ],
               "transactions":[
                  "SSC1"
               ]
            }
         ],
         "createdBy":"TK"
      }
   ]
}
'''


@NonCPS
def parseJSONText(String jsonText) {
    final slurper = new JsonSlurperClassic()
    return new HashMap<>(slurper.parseText(jsonText.trim()))
}
 
def JCL_EXEC_GROOVY_SCRIPT_LOCATION="/u/DMJTA1/groovy"

def INTEGRATION_FOLDER = "tony-jenkins/base/integration-test-case" 
def INTEGRATION_FILE_PATTERN = "*.json"

def SYSOUT_FOLDER = "/u/DMJTA1/vtp/work" 
def SYSOUT_FILE_PATTERN = "*.bzumsg" 
def JENKINS_AGENT_LABEL = "SC47-agent"

def isFolderExist(folderName) {
  folderExist = fileExists file: "${folderName}"
  return folderExist
}

def loadFiles(filePattern,excludes="") {
    return findFiles(glob: "${filePattern}", excludes: "${excludes}")
}

def listOfFiles
def listOfSysOutFiles
def userInputParams
def reviewYesOrNo = false
def emailAddress 

def jsonVar = []

pipeline {

    agent { label "${JENKINS_AGENT_LABEL}" }
    
	parameters {
		string (
			name: 'APPLICATION_LOAD_VALUE',
			defaultValue: 'DMJTA1.LOAD',
			description: 'Enter the application load value'
        )
		string (
			name: 'USER_LOAD_VALUE',
			defaultValue: 'DMJTA1.TEST.LOAD',
			description: 'Enter the user load value'
        )    
	}

    stages {

        stage('Git Checkout') {
            steps {
                script {
                    cleanWs()
                    checkout([$class: 'GitSCM',branches: [[name: "feature/tony-upwork"]],doGenerateSubmoduleConfigurations: false,
                    gitTool: 'Default',
                    submoduleCfg: [],userRemoteConfigs: [[url: "https://github.com/ashokhein/upwork-tasks"]]   ])   
                }
            }
        }

        stage('Load Integration Files') {
            steps {
                script {
                    isIntegrationFolderExist = isFolderExist("${WORKSPACE}/${INTEGRATION_FOLDER}")
                    if(!isIntegrationFolderExist) {
                        println "Integration folder doesn't exist"
                        currentBuild.result = 'FAILURE'
                        error("Job failure to due to integration folder doesn't exist.")
                    }
                    listOfFiles = loadFiles("**/${INTEGRATION_FOLDER}/${INTEGRATION_FILE_PATTERN}")
                    println "List of fileName"
                    listOfFiles.each { fileMetaData ->
                        println fileMetaData.name
                    }
                }
            }
        }
        


        stage('Exec JCL Script') {
             
            steps {
                script {
                        listOfFiles.each { fileMetaData ->
                        println "Executing ${fileMetaData.path}"
                        try {
                            def testcaseJSON = parseJSONText(jsonContent)  
                            testcaseJSON.testCases.each { testCase -> 
                                def testCaseName = testCase.name
                                def testCaseFile = testCase.dataset
                                def testCaseDescription = testCase.description
                                def testedPrograms = []
                                testCase.transactions.each { tx ->
                                    testedPrograms.addAll(tx.programs)
                                }
                                println "TestCaseName : ${testCaseName}"
                                println "TestCaseFile : ${testCaseFile}"
                                println "TestCaseDescription : ${testCaseDescription}"
                                println "TestedPrograms : ${testedPrograms}"
                                println "ApplicationLoadValue : ${APPLICATION_LOAD_VALUE}"
                                println "UserLoadValue : ${USER_LOAD_VALUE}"
                                sh script: '/u/DMJTA1/dbb109fix/bin/groovyz /u/DMJTA1/groovy/2vtp_jcl.groovy -p DMJTA1.DEFECT.DOB -c /u/DMJTA1/vtp -l DMJTA1.LOAD -w /u/DMJTA1/vtp/work', returnStatus: true 
                            }
                            testcaseJSON = null
                        }catch(err) {
                            println "${err}"
                        }
                   }
                    stash includes: "**/${SYSOUT_FOLDER}/**", name: 'sysoutput',allowEmpty: true                          
                }
            }
        }        
 

        stage('Print SysOut') {
            steps {
                script {
                    unstash 'sysoutput'
                    isSysOutFolderExist = isFolderExist("${SYSOUT_FOLDER}")
                    if(!isSysOutFolderExist) {
                        println "Sys out folder doesn't exist"
                        currentBuild.result = 'FAILURE'
                        error("Job failure to due to sys out folder doesn't exist.")                        
                    }
                    listOfSysOutFiles = loadFiles("**/${SYSOUT_FOLDER}/${SYSOUT_FILE_PATTERN}")
                    listOfSysOutFiles.each { fileMetaData ->
                        def sysOut = readFile file: "${fileMetaData.path}", encoding: "UTF-8"
                        println sysOut
                    }
                }
            }
        }

        stage('User Review') {
            steps {
                script { 
                    try {
                        timeout(time: 10, unit: 'MINUTES') { // change to a convenient timeout for you
                            userInputParams = input(message: 'Review', 
                            parameters: [
                                booleanParam(defaultValue: false, description: 'Does the output look fine?',name: 'Yes'),
                                string(defaultValue: "", description: 'Email Address',name: 'Email')
                            ])
                        }
                    } catch(err) { // timeout reached or input false
                        println "User input Timeout or Aborted"
                        userInputParams = false
                    }
                }
            }
        }

        stage('Analysing the User Input') {    
            when {
                expression { userInputParams  } 
            }                     
            steps {
                script { 
                    if(userInputParams.Yes != null && userInputParams.Yes != "" && userInputParams.Yes ) {
                        reviewYesOrNo = true
                    }
                    
                    //Validate the Email
                    if(userInputParams.Email != null && userInputParams.Email != "") {
                        emailAddress = userInputParams.Email
                    } else {
                        if(reviewYesOrNo) {
                            currentBuild.result = 'FAILURE'
                            error("Email address is mandatory if you choose output is 'YES'")                                 
                        }
                    }
                }
            }
        }    

        stage('Sending Email') {
            when {
                expression { reviewYesOrNo  } 
            }            
            steps {
                script { 
                    println "Sending Email to ${emailAddress}"
                    // emailext body: 'Test Message', subject: 'Test Subject',to: "${emailAddress}"                    
                }
            }
        }    

        stage('Reverting Git Commit') {
            when {
                expression { !reviewYesOrNo  } 
            }            
            steps {
                script { 
                    println "Reverting GitCommit"
                }
            }
        } 
    }
}