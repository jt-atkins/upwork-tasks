import groovy.json.*

def JCL_EXEC_GROOVY_SCRIPT_LOCATION="tony-jenkins"

def INTEGRATION_FOLDER = "tony-jenkins/base/integration-test-case" 
def INTEGRATION_FILE_PATTERN = "*.json"

def SYSOUT_FOLDER = "output" 
def SYSOUT_FILE_PATTERN = "*.bzumsg" 
def JENKINS_AGENT_LABEL = "vagrant"

def isFolderExist(folderName) {
  folderExist = fileExists file: "${folderName}"
  return folderExist
}

def loadFiles(filePattern,excludes="") {
    return findFiles(glob: "${filePattern}", excludes: "${excludes}")
}

def listOfFiles
def listOfSysOutFiles
def userInputParams
def reviewYesOrNo = false
def emailAddress 

pipeline {

    agent any
    
	parameters {
		string (
			name: 'APPLICATION_LOAD_VALUE',
			defaultValue: 'ALOAD',
			description: 'Enter the application load value'
        )
		string (
			name: 'USER_LOAD_VALUE',
			defaultValue: 'ULOAD',
			description: 'Enter the user load value'
        )    
	}

    stages {

        stage('Git Checkout') {
            steps {
                script {
                    cleanWs()
                    checkout([$class: 'GitSCM',branches: [[name: scm.branches[0].name]],doGenerateSubmoduleConfigurations: false,
                    gitTool: 'Default',
                    submoduleCfg: [],userRemoteConfigs: [[url: "https://github.com/ashokhein/upwork-tasks"]]   ])   
                }
            }
        }

        stage('Load Integration Files') {
            steps {
                script {
                    isIntegrationFolderExist = isFolderExist("${WORKSPACE}/${INTEGRATION_FOLDER}")
                    if(!isIntegrationFolderExist) {
                        println "Integration folder doesn't exist"
                        currentBuild.result = 'FAILURE'
                        error("Job failure to due to integration folder doesn't exist.")
                    }
                    listOfFiles = loadFiles("**/${INTEGRATION_FOLDER}/${INTEGRATION_FILE_PATTERN}")
                    println "List of fileName"
                    listOfFiles.each { fileMetaData ->
                        println fileMetaData.name
                    }
                }
            }
        }

        stage('Exec JCL Script') {       
            steps {
                script {
                    listOfFiles.each { fileMetaData ->
                        println "Executing ${fileMetaData.path}"
                        try {
                            // def jsonSlurper = new JsonSlurper()
                            // def reader = new BufferedReader(new InputStreamReader(new FileInputStream("${fileMetaData.path}"), 'UTF-8'))
                            // def testcaseJSON = jsonSlurper.parse(reader)  
                            // def testcaseJSON = readJSON file: "${fileMetaData.path}"
                            def testcaseJSON = sh(script: "cat ${WORKSPACE}/${fileMetaData.path} | jq",returnStdout: true)
                            println testcaseJSON
                            testcaseJSON.testCases.each { testCase -> 
                                def testCaseName = testCase.name
                                def testCaseFile = testCase.dataset
                                def testCaseDescription = testCase.description
                                def testedPrograms = []
                                testCase.transactions.each { tx ->
                                    testedPrograms.addAll(tx.programs)
                                }
                                println "TestCaseName : ${testCaseName}"
                                println "TestCaseFile : ${testCaseFile}"
                                println "TestCaseDescription : ${testCaseDescription}"
                                println "TestedPrograms : ${testedPrograms}"
                                println "ApplicationLoadValue : ${APPLICATION_LOAD_VALUE}"
                                println "UserLoadValue : ${USER_LOAD_VALUE}"
                                groovyz "${JCL_EXEC_GROOVY_SCRIPT_LOCATION}/jclexec.groovy -p ${testCaseFile} -c ${WORKSPACE} -l ${APPLICATION_LOAD_VALUE} -w ${WORKSPACE}/${SYSOUT_FOLDER}"  
                            }
                        }catch(err) {
                            println "${err}"
                        }
                   }
                    stash includes: "**/${SYSOUT_FOLDER}/**", name: 'sysoutput',allowEmpty: true                          
                }
            }
        }        
 

        stage('Print SysOut') {
            steps {
                script {
                    unstash 'sysoutput'
                    isSysOutFolderExist = isFolderExist("${WORKSPACE}/${SYSOUT_FOLDER}")
                    if(!isSysOutFolderExist) {
                        println "Sys out folder doesn't exist"
                        currentBuild.result = 'FAILURE'
                        error("Job failure to due to sys out folder doesn't exist.")                        
                    }
                    listOfSysOutFiles = loadFiles("**/${SYSOUT_FOLDER}/${SYSOUT_FILE_PATTERN}")
                    listOfSysOutFiles.each { fileMetaData ->
                        def sysOut = readFile file: "${WORKSPACE}/${fileMetaData.path}", encoding: "UTF-8"
                        println sysOut
                    }
                }
            }
        }

        stage('User Review') {
            steps {
                script { 
                    try {
                        timeout(time: 10, unit: 'MINUTES') { // change to a convenient timeout for you
                            userInputParams = input(message: 'Review', 
                            parameters: [
                                booleanParam(defaultValue: false, description: 'Does the output look fine?',name: 'Yes'),
                                string(defaultValue: "", description: 'Email Address',name: 'Email')
                            ])
                        }
                    } catch(err) { // timeout reached or input false
                        println "User input Timeout or Aborted"
                        userInputParams = false
                    }
                }
            }
        }

        stage('Analysing the User Input') {    
            when {
                expression { userInputParams  } 
            }                     
            steps {
                script { 
                    if(userInputParams.Yes != null && userInputParams.Yes != "" && userInputParams.Yes ) {
                        reviewYesOrNo = true
                    }
                    
                    //Validate the Email
                    if(userInputParams.Email != null && userInputParams.Email != "") {
                        emailAddress = userInputParams.Email
                    } else {
                        if(reviewYesOrNo) {
                            currentBuild.result = 'FAILURE'
                            error("Email address is mandatory if you choose output is 'YES'")                                 
                        }
                    }
                }
            }
        }    

        stage('Sending Email') {
            when {
                expression { reviewYesOrNo  } 
            }            
            steps {
                script { 
                    println "Sending Email to ${emailAddress}"
                    // emailext body: 'Test Message', subject: 'Test Subject',to: "${emailAddress}"                    
                }
            }
        }    

        stage('Reverting Git Commit') {
            when {
                expression { !reviewYesOrNo  } 
            }            
            steps {
                script { 
                    println "Reverting GitCommit"
                }
            }
        } 
    }
}
